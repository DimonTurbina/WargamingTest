# Тестовое задание на позицию Programming intern в компании Wargaming Санкт-Петербург


## Задание 1:
---
На языке Python или С/С++, написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути.

Объяснить плюсы и минусы обеих реализаций.



Python example:

```
def isEven(value):
   return value % 2 == 0
```

C/C++ example:
``` С++
bool isEven(int value)
{
   return value % 2 == 0;
}
```
---
### Решение:
``` С++
bool isEven2(int value)
{
    return (value & 1) == 0;
}
```
Плюс второй реализации в том, что мы изначально используем более быструю операцию - побитовое "и". Некоторые компиляторы могут не производить оптимизацию и на уровне ассемблера при делении на 2 может вызываться более дорогую инструкция idiv.

## Задание 2:
---
На языках Python(2.7) и/или С++, написать минимум по 2 класса реализовывающих циклический буфер FIFO.

Объяснить плюсы и минусы каждой реализации.

---

В файле СircularBufferArray.h представлена реализация буфера с помощью массива. Реализованы методы добавления в конец и в начало буффера, добавление и удаление по индексу, удаления из начала и конца буффера, изменения размера буфераб получения самого старого и самого нового элемента. Принцип FIFO соблюден - при добавлении новых элементов в полностью заполненный буфер самые старые удаляются.

Плюсы:

    1. Операция доступа к элементу происходит за Θ(1)
    2. Количество расходуемой памяти меньше, так как нам не приходится хранить указатели
    3. Бонусом идет поддержка stl алгоритмов таких как std::sort, std::min_element, std::all_of и т.д. (Реализован итератор)
Минусы:

    1. Операция вставки и удаления элемента имеет асимптотическую сложность Θ(n)
В файле CircularBufferList.h представлена реализация буфера через односвязный список. Реализованы методы добавления и удаления элемента, получения самого старого элемента, проверка на пустоту, очистка буфера

Плюсы:

    1. Операция доступа к самому старому элементу происходит за Θ(1);
    2. Добавление элемента происходит за Θ(1);
    3. Код простой и был написан быстро

Минусы:

    1. Если нам нужен не самый старый элемент, то доступ к нему будет за Θ(n)
    2. Используется больше памяти

## Задание 3:
---
На языке Python или С/С++, написать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел.

Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным).

Объяснить почему вы считаете, что функция соответствует заданным критериям.

---

После прочтения задания я понял, что нужно углубиться в теорию и почитать про что-то более мудренное и необычное, чем стандартные quicksort и heapsort. В итоге я нашел и изучил информацию про два отличных алгоритма: introsort и timsort. Оба являются комбинациями сразу нескольких сортировок. Мой выбор пал на introsort - модификацию quicksort с переключением на пирамидальную, так как несмотря на одинаковую асимпотику Θ(nlogn) в худшем случаи, introsort немного выигрывает по скорости в тестах. Оданко достоинствам timsort можно добавить то, что она усточивая в отличие от introsort, но в условии не было уточнялось на сколько это важно.  